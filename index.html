<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Techno Artist Collaboration Network</title>
    <script src="https://cdn.jsdelivr.net/npm/graphology@0.18.0/dist/graphology.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/louvain.js@0.1.0/dist/louvain.min.js"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        svg { width: 100vw; height: 100vh; }
        #controls { position: absolute; top: 20px; left: 20px; background-color: rgba(255, 255, 255, 0.7); padding: 10px; }
        select { padding: 5px; }
    </style>
</head>
<body>
    <div id="controls">
        <label for="algorithm-select">Community Detection Algorithm: </label>
        <select id="algorithm-select">
            <option value="louvain">Louvain</option>
            <option value="girvan-newman">Girvan-Newman</option>
            <option value="label-propagation">Label Propagation</option>
        </select>
    </div>

    <script>
        d3.json('techno_graph_data.json').then(function(graphData) {
            const width = window.innerWidth, height = window.innerHeight;

            const svg = d3.select('body').append('svg')
                .attr('width', width)
                .attr('height', height);

            const link = svg.append('g').selectAll('.link')
                .data(graphData.links)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', 2)
                .attr('stroke', '#999');

            const node = svg.append('g').selectAll('.node')
                .data(graphData.nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', 5)
                .attr('fill', '#1f77b4')
                .call(d3.drag().on('start', dragstart).on('drag', dragged).on('end', dragend));

            const label = svg.append('g').selectAll('.label')
                .data(graphData.nodes)
                .enter().append('text')
                .attr('class', 'label')
                .attr('dx', 10)
                .attr('dy', 5)
                .text(d => d.id);

            const simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('center', d3.forceCenter(width / 2, height / 2));

            simulation
                .nodes(graphData.nodes)
                .on('tick', ticked);

            simulation.force('link')
                .links(graphData.links);

            function ticked() {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            }

            function dragstart(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragend(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            // Add event listener to the algorithm selector
            d3.select("#algorithm-select").on("change", function() {
                const selectedAlgorithm = this.value;
                applyCommunityDetection(selectedAlgorithm);
            });

            // Apply the community detection algorithms
            function applyCommunityDetection(algorithm) {
                let communities;
                switch (algorithm) {
                    case "louvain":
                        communities = louvain(graphData);
                        break;
                    case "girvan-newman":
                        communities = girvanNewman(graphData);
                        break;
                    case "label-propagation":
                        communities = labelPropagation(graphData);
                        break;
                }
                // Update node colors based on community
                node.attr('fill', d => communities[d.id].color);
            }

            // Louvain algorithm implementation
            function louvain(graphData) {
                const graph = new graphology.Graph();
                graphData.nodes.forEach(node => graph.addNode(node.id));
                graphData.links.forEach(link => graph.addEdge(link.source, link.target));

                const louvainResults = louvainAlgorithm(graph);
                return assignColorsToCommunities(louvainResults);
            }

            // Girvan-Newman algorithm implementation
            function girvanNewman(graphData) {
                const graph = new graphology.Graph();
                graphData.nodes.forEach(node => graph.addNode(node.id));
                graphData.links.forEach(link => graph.addEdge(link.source, link.target));

                const betweenness = graph.betweenness();
                const communities = girvanNewmanAlgorithm(graph, betweenness);
                return assignColorsToCommunities(communities);
            }

            // Label Propagation (Placeholder)
            function labelPropagation(graphData) {
                const graph = new graphology.Graph();
                graphData.nodes.forEach(node => graph.addNode(node.id));
                graphData.links.forEach(link => graph.addEdge(link.source, link.target));

                const communities = labelPropagationAlgorithm(graph);
                return assignColorsToCommunities(communities);
            }

            // Helper function to assign colors to communities
            function assignColorsToCommunities(communityData) {
                const communityColors = d3.scaleOrdinal(d3.schemeCategory10);
                let communityMap = {};
                communityData.forEach((community, idx) => {
                    communityMap[community.node] = { 
                        community: community.community, 
                        color: communityColors(community.community)
                    };
                });
                return communityMap;
            }
        });
    </script>
</body>
</html>
